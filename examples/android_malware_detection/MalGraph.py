#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   GraphDroid.py
@Time    :   2021/10/04 21:11:44
@Author  :   Yiling He
@Version :   1.0
@Contact :   heyilinge0@gmail.com
@License :   (C)Copyright 2021
@Desc    :   None
'''

# here put the import lib
import os.path as osp
import numpy as np
import re
import networkx as nx
import torch
from pathlib import Path
from torch_geometric.data import Data

from ai4code.features.preprocessing.android import APKAnalyzer
from ai4code.features.resources import get_resource, INSTRUCTION_CLASSES, INSTRUCTION_SET_COLOR
from ai4code.features.normalization import get_existence_vector, get_frequency_vector, concatenate_numpy_array

from transformers import AutoTokenizer, AutoModel
from sentence_transformers import SentenceTransformer
from tqdm import tqdm


PERMISSIONS = get_resource('android_permissions')
opcode_specified = False
OPCODES = get_resource('samli_opcodes') if opcode_specified else INSTRUCTION_CLASSES
EXTERNAL = 768

class MalGraphAnalyzer(APKAnalyzer):
    def __init__(self, apkpath, ana_obj=None): # , apk_label
        super(MalGraphAnalyzer, self).__init__(apkpath, ana_obj=ana_obj)
        # self.label = apk_label
        self.features = self.get_graph()

    def get_graph(self):
        call_graph = self.get_call_graph()

        node_attributes = []
        node_api = []
        node_types = [] # internal(TPL, SELF), external(SENSITIVE, INSEN)

        cfg_list = []
        index = 0

        # codebert
        tokenizer = AutoTokenizer.from_pretrained("microsoft/codebert-base")
        model = AutoModel.from_pretrained("microsoft/codebert-base")

        for node in tqdm(call_graph.nodes):
            node_external_attr = np.zeros(EXTERNAL) # external fucntion embeddings
            # node_local_attr = get_existence_vector([], OPCODES) # internal opcodes of the method
            
            # node_api.append(str(node.full_name))

            if node.is_android_api():
                node_external_attr = self.get_external_vector(node, model, tokenizer)
            elif node.is_external(): 
                node_external_attr = self.get_external_vector(node, model, tokenizer)
            else: # local
                # node_opc_attr = self.get_opcode_vector(opc_list=self.get_method_tokens(node))

                cfg, method_info = self.get_method_cfg(node)
                cfg_node_attributes = []
                for bb in cfg.nodes:
                    cfg_node_attr = self.get_opcode_vector(opc_list=cfg.nodes[bb]['opcode']) # 15
                    cfg_node_attributes.append(cfg_node_attr)

                cfg_edges = []
                cfg_edge_types = []
                cfg = nx.convert_node_labels_to_integers(cfg)
                for src, dst, attr in cfg.edges(data=True):
                    cfg_edges.append([src, dst])
                    cfg_edge_types.append(attr['type'])

                cfg_node_attributes = torch.tensor(cfg_node_attributes, dtype=torch.float)
                cfg_edge_index = torch.tensor(cfg_edges, dtype=torch.long).t().contiguous()
                cfg_edge_types = torch.tensor(cfg_edge_types, dtype=torch.long).unsqueeze(-1)

                cfg_list.append(Data(x=cfg_node_attributes, edge_index=cfg_edge_index, edge_attr=cfg_edge_types, local_idx=index))

            # print(node.full_name, len(node_per_attr), len(node_opc_attr), len(node_pkg_attr))
            node_attr = node_external_attr # 684 + 15(224) =699(908)
            node_attributes.append(node_attr)

            index += 1


        # graph_dict = {"node_attributes": node_attributes, "edge_list": edge_list, \
        #     "mapping": node_api, "app": osp.splitext(self.filepath)[0], "types": node_types} # , "label": self.label
            
        call_graph = nx.convert_node_labels_to_integers(call_graph)
        edge_list = []
        for src, dst, _ in list(call_graph.edges):
            edge_list.append([src, dst])
        node_attributes = torch.tensor(np.array(node_attributes), dtype=torch.float)
        edge_index = torch.tensor(edge_list, dtype=torch.long).t().contiguous()

        return Data(x=node_attributes, edge_index=edge_index, cfg_list=cfg_list, hash=Path(self.filepath).stem)

    def get_opcode_vector(self, opc_list, specific=False):
        if specific:
            return self.get_opcode_vector_specific(opc_list)
        
        opc_class_list = []
        for opc in opc_list:
            opc_class_list.append(OPCODES[INSTRUCTION_SET_COLOR[opc]])
        return get_frequency_vector(opc_class_list, OPCODES, divide=True)
    
    def get_opcode_vector_specific(self, opc_list):
        return get_frequency_vector(opc_list, OPCODES)

    def get_external_vector(self, node, model, tokenizer):
        preprocessed_name = self.preprocess_function_name(str(node.full_name))
        inputs = tokenizer(preprocessed_name, return_tensors="pt", max_length=128, truncation=True, padding="max_length")
        outputs = model(**inputs)
        feature_vector = outputs.last_hidden_state[:, 0, :].detach().numpy()[0]

        return feature_vector

    def preprocess_function_name(self, full_name):
        class_path, method_signature = full_name.split(';', 1)
        class_name = class_path.replace('/', ' ')
        method_name = method_signature.split()[0]  # Get the method name before the space
        
        # Normalize class and method names
        # Split camelCase and snake_case, and convert to lowercase
        def normalize(name):
            name = re.sub(r'[_$]', ' ', name)
            name = re.sub(r'[^a-zA-Z ]+', '', name)  # Remove digits
            name = re.sub('([a-z0-9])([A-Z])', r'\1 \2', name)  # Split camelCase
            return name.lower()
        
        normalized_class_name = normalize(class_name)
        normalized_method_name = normalize(method_name)
        
        # Combine class and method names
        full_normalized_name = f"{normalized_class_name} {normalized_method_name}"
        return full_normalized_name